# slipwire
A strongly decoupled architecture for android applications, based on RxJava.

***Slipwire*** is framework for building Android applications, which, following the MVP pattern, aims to strictly decouple Android View instances from application flow and logic. To achieve this, Slipwire introduces a second bus, the DataBus, and makes an abstraction on the data flow between a Presenter and it's Display interface - the Presenter represents a DataSource and the Presenter.Display interface represents a DataSink. Thus, we can have only the Presenter.Display (an adapter) that is loosely coupled to the Android View instance.

where a view is decoupled from the application logic and flow-control - views are only aware of a DataSource interface, and a type `<? extends Data>` that it is able to visualize. It utilises an EventBus and a DataBus, where a view is injected with a DataSource, and the Presenter.Display interface acts as a DataSink. The introduction of a DataBus, along with the DataSource interface, allow the Presenter to mediate (provide,cache) the data accessible to a view. As such, a view can 'request' more data, but consumes data in a reactive manner.

*An adapter class that implements a Presenter.Display interface may exist and be coupled to a view, but the view (and any backing-store adpater) itself need not be subclassed to contain any reactive code.*

<img src="https://docs.google.com/drawings/d/1k1kYMa2RuOlPbSxPCuSGIr2_Aa_GZToKcL8CRTUJ0i8/pub?w=960&amp;h=720">

<a href="https://docs.google.com/drawings/d/1k1kYMa2RuOlPbSxPCuSGIr2_Aa_GZToKcL8CRTUJ0i8/edit?usp=sharing" target="_blank">https://docs.google.com/drawings/d/1k1kYMa2RuOlPbSxPCuSGIr2_Aa_GZToKcL8CRTUJ0i8/edit?usp=sharing</a>

In ***slipwire***, tasks are treated the same as network fetches. A local HTTP server runs and provides a servlet-like conatiner
to run jobs (joblets). An action class mediates the execution of a job. For example, an event may result in an action that subscribes to an observable over an http://localhost:* call. This results in the execution of a joblet. Perhaps this joblet broadcasts an intent for image selection from users gallery. Treating localized work in this asynchronous way leads to modularization and decoupling of the components of an application.

##### DEPENDENCIES <br>
compile 'io.reactivex:rxandroid:1.0.1'          [LICENSE](https://github.com/ReactiveX/RxAndroid) <br>
compile 'io.reactivex:rxjava:1.0.14'            [LICENSE](https://github.com/ReactiveX/RxJava) <br>
compile 'com.squareup.retrofit:retrofit:1.9.0'  [LICENSE](http://square.github.io/retrofit/) <br>



# slipwire
A strongly decoupled architecture for android applications, based on RxJava.

***Slipwire*** is framework for building Android applications, which, following the MVP pattern, aims to strictly decouple Android View instances from application flow and logic. To achieve this, Slipwire introduces a second bus, the *DataBus*, and makes an abstraction on the data flow between a Presenter and it's Display interface. A Presenter represents a *DataSource* and it's Presenter.Display interface represents a *DataSink*. Thus, we can have that only the Presenter.Display is loosely coupled to the Android View instance. This promotes describing View by their XML layouts, and discourages extending View classes (for purposes other than data visualization). A further level of abstraction could be introduced, whereby an Android View is extended to implement, say, a "Visualize" interface, and thus a Presenter.Display potentially need not know of any Android View types nor the "resource-id" mechanism, but this is not strictly necessary to achieve a loose coupling.

Apart from the de-coupling of Android Views, Slipwire also maintains separation of concerns by treating "localized" tasks, or *Action*s, as asynchronous bahaviours that are basically the equivalent (analagogues) of network or RPC request/response operations. So, we introduce the notion of a *Joblet*, in which a self-contained unit of execution can perform work on behalf of the application. A Joblet can be thought of as a Servlet that is not sandboxed within the Android runtime - in fact, it is an instance of an embedded Jetty server, with a "JobletHandler", that is the umbrella under which a Joblet is running. To the Slipwire application, network fetches and local jobs are treated in the same way - both are invoked as RXJava Observables wrapping (Retrofit/Volley) HTTP request/response sessions. The development of a Slipwire application can benefit from the concurrent development of Joblets, and Joblets lend themselves to mock unit testing.

So, in Slipwire, we have a de-coupling of components that act on the data which flows thru an application - MVP pattern, Joblets. Therefore, it is up to the *DataBus* to satisfy the data consumer needs of the de-coupled components. Both the *EventBus* and *DataBus* in Slipwire are implemented as RxJava Subjects, and any component can be an Observer on either bus or both. However, Slipwire encourages that an application follow some restrictions: that Presenter(s) shall be the


##### DEPENDENCIES <br>
compile 'io.reactivex:rxandroid:1.0.1'          [LICENSE](https://github.com/ReactiveX/RxAndroid) <br>
compile 'io.reactivex:rxjava:1.0.14'            [LICENSE](https://github.com/ReactiveX/RxJava) <br>
compile 'com.squareup.retrofit:retrofit:1.9.0'  [LICENSE](http://square.github.io/retrofit/) <br>
